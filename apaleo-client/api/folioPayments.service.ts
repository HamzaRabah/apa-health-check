/**
 * apaleo Inventory API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { CreateAccountPaymentRequest } from '../model/createAccountPaymentRequest';
// @ts-ignore
import { CreateAuthorizationPaymentRequest } from '../model/createAuthorizationPaymentRequest';
// @ts-ignore
import { CreateCustomPaymentRequest } from '../model/createCustomPaymentRequest';
// @ts-ignore
import { CreateFolioRefundRequest } from '../model/createFolioRefundRequest';
// @ts-ignore
import { CreatePaymentLinkRequest } from '../model/createPaymentLinkRequest';
// @ts-ignore
import { CreatePaymentRefundRequest } from '../model/createPaymentRefundRequest';
// @ts-ignore
import { CreateTerminalPaymentRequest } from '../model/createTerminalPaymentRequest';
// @ts-ignore
import { FolioPaymentModel } from '../model/folioPaymentModel';
// @ts-ignore
import { MessageItemCollection } from '../model/messageItemCollection';
// @ts-ignore
import { PaymentCreatedModel } from '../model/paymentCreatedModel';
// @ts-ignore
import { PaymentListModel } from '../model/paymentListModel';
// @ts-ignore
import { RefundCreatedModel } from '../model/refundCreatedModel';
// @ts-ignore
import { RefundListModel } from '../model/refundListModel';
// @ts-ignore
import { RefundModel } from '../model/refundModel';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class FolioPaymentsService {

    protected basePath = 'https://api.apaleo.com';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Captures a specific amount from a pre-authorization and posts it to the folio.
     * Captures a specific amount from a pre-authorization and posts it to the folio. For the pre-authorization please ensure to set the respective metadata in the original payment  transaction. The flow type has to be set to &lt;i&gt;CaptureOnly&lt;/i&gt;. For more information please refer to the documentation of &lt;a href&#x3D;\&quot;https://apaleo.dev/guides/business-cases/ibe/getting-the-money\&quot; target&#x3D;\&quot;_blank\&quot;&gt;how to do a pre-authorization on a booking engine&lt;/a&gt;.  The payment will be processed asynchronously. Use the location header to poll for the status of the payment. As long as a payment is pending it reduces the amount of allowed  payments for the folio. The payment times out after 60 minutes automatically&lt;br&gt;You must have this scope: \&#39;folios.manage\&#39;.
     * @param folioId
     * @param body The definition of the payment.
     * @param idempotencyKey Unique key for safely retrying requests without accidentally performing the same operation twice.  We\&#39;ll always send back the same response for requests made with the same key,  and keys can\&#39;t be reused with different request parameters. Keys expire after 24 hours.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeFoliosByFolioIdPaymentsByAuthorizationPost(folioId: string, body: CreateAuthorizationPaymentRequest, idempotencyKey?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PaymentCreatedModel>;
    public financeFoliosByFolioIdPaymentsByAuthorizationPost(folioId: string, body: CreateAuthorizationPaymentRequest, idempotencyKey?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PaymentCreatedModel>>;
    public financeFoliosByFolioIdPaymentsByAuthorizationPost(folioId: string, body: CreateAuthorizationPaymentRequest, idempotencyKey?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PaymentCreatedModel>>;
    public financeFoliosByFolioIdPaymentsByAuthorizationPost(folioId: string, body: CreateAuthorizationPaymentRequest, idempotencyKey?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeFoliosByFolioIdPaymentsByAuthorizationPost.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling financeFoliosByFolioIdPaymentsByAuthorizationPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (idempotencyKey !== undefined && idempotencyKey !== null) {
            localVarHeaders = localVarHeaders.set('Idempotency-Key', String(idempotencyKey));
        }

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<PaymentCreatedModel>(`${this.configuration.basePath}/finance/v1/folios/${encodeURIComponent(String(folioId))}/payments/by-authorization`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a link to a payment form where guests can pay.
     * Creates a link to a payment form where guests can pay. To enable open invoice payment methods you need to provide at  least the paid charges with the request. For some open invoice payment methods you also need to ensure that the full  billing address of the folio is set, before you create the payment link. The payment will be processed asynchronously.  Use the location header to poll for the status of the payment. As long as a payment is pending it reduces the amount  of allowed payments for the folio.&lt;br&gt;You must have this scope: \&#39;folios.manage\&#39;.
     * @param folioId
     * @param body The definition of the payment link.
     * @param idempotencyKey Unique key for safely retrying requests without accidentally performing the same operation twice.  We\&#39;ll always send back the same response for requests made with the same key,  and keys can\&#39;t be reused with different request parameters. Keys expire after 24 hours.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeFoliosByFolioIdPaymentsByLinkPost(folioId: string, body: CreatePaymentLinkRequest, idempotencyKey?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PaymentCreatedModel>;
    public financeFoliosByFolioIdPaymentsByLinkPost(folioId: string, body: CreatePaymentLinkRequest, idempotencyKey?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PaymentCreatedModel>>;
    public financeFoliosByFolioIdPaymentsByLinkPost(folioId: string, body: CreatePaymentLinkRequest, idempotencyKey?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PaymentCreatedModel>>;
    public financeFoliosByFolioIdPaymentsByLinkPost(folioId: string, body: CreatePaymentLinkRequest, idempotencyKey?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeFoliosByFolioIdPaymentsByLinkPost.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling financeFoliosByFolioIdPaymentsByLinkPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (idempotencyKey !== undefined && idempotencyKey !== null) {
            localVarHeaders = localVarHeaders.set('Idempotency-Key', String(idempotencyKey));
        }

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<PaymentCreatedModel>(`${this.configuration.basePath}/finance/v1/folios/${encodeURIComponent(String(folioId))}/payments/by-link`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trigger a payment using the payment account stored on the reservation.
     * Trigger a payment for the folio using the payment account stored on the reservation. The payment will be processed asynchronously. Use the location header to poll  for the status of the payment. As long as a payment is pending it reduces the amount of allowed payments for the folio. The payment times out after 60 minutes  automatically&lt;br&gt;You must have this scope: \&#39;folios.manage\&#39;.
     * @param folioId
     * @param body The definition of the payment.
     * @param idempotencyKey Unique key for safely retrying requests without accidentally performing the same operation twice.  We\&#39;ll always send back the same response for requests made with the same key,  and keys can\&#39;t be reused with different request parameters. Keys expire after 24 hours.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeFoliosByFolioIdPaymentsByPaymentAccountPost(folioId: string, body: CreateAccountPaymentRequest, idempotencyKey?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PaymentCreatedModel>;
    public financeFoliosByFolioIdPaymentsByPaymentAccountPost(folioId: string, body: CreateAccountPaymentRequest, idempotencyKey?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PaymentCreatedModel>>;
    public financeFoliosByFolioIdPaymentsByPaymentAccountPost(folioId: string, body: CreateAccountPaymentRequest, idempotencyKey?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PaymentCreatedModel>>;
    public financeFoliosByFolioIdPaymentsByPaymentAccountPost(folioId: string, body: CreateAccountPaymentRequest, idempotencyKey?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeFoliosByFolioIdPaymentsByPaymentAccountPost.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling financeFoliosByFolioIdPaymentsByPaymentAccountPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (idempotencyKey !== undefined && idempotencyKey !== null) {
            localVarHeaders = localVarHeaders.set('Idempotency-Key', String(idempotencyKey));
        }

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<PaymentCreatedModel>(`${this.configuration.basePath}/finance/v1/folios/${encodeURIComponent(String(folioId))}/payments/by-payment-account`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancels a payment.
     * Sets a payment to cancelled and triggers the cancellation.&lt;br&gt;You must have this scope: \&#39;folios.manage\&#39;.
     * @param folioId
     * @param paymentId The id of the payment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeFoliosByFolioIdPaymentsByPaymentIdCancelPut(folioId: string, paymentId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public financeFoliosByFolioIdPaymentsByPaymentIdCancelPut(folioId: string, paymentId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public financeFoliosByFolioIdPaymentsByPaymentIdCancelPut(folioId: string, paymentId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public financeFoliosByFolioIdPaymentsByPaymentIdCancelPut(folioId: string, paymentId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeFoliosByFolioIdPaymentsByPaymentIdCancelPut.');
        }
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling financeFoliosByFolioIdPaymentsByPaymentIdCancelPut.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.put<any>(`${this.configuration.basePath}/finance/v1/folios/${encodeURIComponent(String(folioId))}/payments/${encodeURIComponent(String(paymentId))}/cancel`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a payment by ID.
     * Get a payment by its ID&lt;br&gt;You must have at least one of these scopes: \&#39;folios.read, folios.manage\&#39;.
     * @param folioId
     * @param paymentId The payment ID.
     * @param expand List of all embedded resources that should be expanded in the response. Possible values are: actions. All other values will be silently ignored.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeFoliosByFolioIdPaymentsByPaymentIdGet(folioId: string, paymentId: string, expand?: Array<'actions'>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<FolioPaymentModel>;
    public financeFoliosByFolioIdPaymentsByPaymentIdGet(folioId: string, paymentId: string, expand?: Array<'actions'>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<FolioPaymentModel>>;
    public financeFoliosByFolioIdPaymentsByPaymentIdGet(folioId: string, paymentId: string, expand?: Array<'actions'>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<FolioPaymentModel>>;
    public financeFoliosByFolioIdPaymentsByPaymentIdGet(folioId: string, paymentId: string, expand?: Array<'actions'>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeFoliosByFolioIdPaymentsByPaymentIdGet.');
        }
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling financeFoliosByFolioIdPaymentsByPaymentIdGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (expand) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                expand.join(COLLECTION_FORMATS['csv']), 'expand');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<FolioPaymentModel>(`${this.configuration.basePath}/finance/v1/folios/${encodeURIComponent(String(folioId))}/payments/${encodeURIComponent(String(paymentId))}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trigger a refund for a specific payment.
     * Trigger a refund for a specific payment on this folio. The refund will be processed asynchronously. Use the location header to poll for  the status of the refund. As long as a refund is pending the allowed refund amount for this payment will be reduced by the amount. The refund  times out after 10 minutes automatically&lt;br&gt;You must have this scope: \&#39;folios.manage\&#39;.
     * @param folioId
     * @param paymentId The payment Id.
     * @param body The definition of the refund.
     * @param idempotencyKey Unique key for safely retrying requests without accidentally performing the same operation twice.  We\&#39;ll always send back the same response for requests made with the same key,  and keys can\&#39;t be reused with different request parameters. Keys expire after 24 hours.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeFoliosByFolioIdPaymentsByPaymentIdRefundsPost(folioId: string, paymentId: string, body: CreatePaymentRefundRequest, idempotencyKey?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<RefundCreatedModel>;
    public financeFoliosByFolioIdPaymentsByPaymentIdRefundsPost(folioId: string, paymentId: string, body: CreatePaymentRefundRequest, idempotencyKey?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<RefundCreatedModel>>;
    public financeFoliosByFolioIdPaymentsByPaymentIdRefundsPost(folioId: string, paymentId: string, body: CreatePaymentRefundRequest, idempotencyKey?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<RefundCreatedModel>>;
    public financeFoliosByFolioIdPaymentsByPaymentIdRefundsPost(folioId: string, paymentId: string, body: CreatePaymentRefundRequest, idempotencyKey?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeFoliosByFolioIdPaymentsByPaymentIdRefundsPost.');
        }
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling financeFoliosByFolioIdPaymentsByPaymentIdRefundsPost.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling financeFoliosByFolioIdPaymentsByPaymentIdRefundsPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (idempotencyKey !== undefined && idempotencyKey !== null) {
            localVarHeaders = localVarHeaders.set('Idempotency-Key', String(idempotencyKey));
        }

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<RefundCreatedModel>(`${this.configuration.basePath}/finance/v1/folios/${encodeURIComponent(String(folioId))}/payments/${encodeURIComponent(String(paymentId))}/refunds`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trigger a payment on a card terminal for the folio.
     * Trigger a terminal payment for the folio. The payment will be processed asynchronously. Use the location header to poll for the status of the payment.  As long as a payment is pending it reduces the amount of allowed payments for the folio. The payment times out after 60 minutes automatically&lt;br&gt;You must have this scope: \&#39;folios.manage\&#39;.
     * @param folioId
     * @param body The definition of the payment.
     * @param idempotencyKey Unique key for safely retrying requests without accidentally performing the same operation twice.  We\&#39;ll always send back the same response for requests made with the same key,  and keys can\&#39;t be reused with different request parameters. Keys expire after 24 hours.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeFoliosByFolioIdPaymentsByTerminalPost(folioId: string, body: CreateTerminalPaymentRequest, idempotencyKey?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PaymentCreatedModel>;
    public financeFoliosByFolioIdPaymentsByTerminalPost(folioId: string, body: CreateTerminalPaymentRequest, idempotencyKey?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PaymentCreatedModel>>;
    public financeFoliosByFolioIdPaymentsByTerminalPost(folioId: string, body: CreateTerminalPaymentRequest, idempotencyKey?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PaymentCreatedModel>>;
    public financeFoliosByFolioIdPaymentsByTerminalPost(folioId: string, body: CreateTerminalPaymentRequest, idempotencyKey?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeFoliosByFolioIdPaymentsByTerminalPost.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling financeFoliosByFolioIdPaymentsByTerminalPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (idempotencyKey !== undefined && idempotencyKey !== null) {
            localVarHeaders = localVarHeaders.set('Idempotency-Key', String(idempotencyKey));
        }

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<PaymentCreatedModel>(`${this.configuration.basePath}/finance/v1/folios/${encodeURIComponent(String(folioId))}/payments/by-terminal`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of payments.
     * Returns a list of all payments for this folio ordered by creation date, newest first&lt;br&gt;You must have at least one of these scopes: \&#39;folios.read, folios.manage\&#39;.
     * @param folioId
     * @param statusCodes Filter payments by one or more status.
     * @param pageNumber Page number, starting from 1 and defaulting to 1. Results in 204 if there are no items on that page.
     * @param pageSize Page size. If this is not set, the pageNumber will be ignored and all values returned.
     * @param expand List of all embedded resources that should be expanded in the response. Possible values are: actions. All other values will be silently ignored.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeFoliosByFolioIdPaymentsGet(folioId: string, statusCodes?: Array<'Pending' | 'Success' | 'Failure' | 'Canceled'>, pageNumber?: number, pageSize?: number, expand?: Array<'actions'>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PaymentListModel>;
    public financeFoliosByFolioIdPaymentsGet(folioId: string, statusCodes?: Array<'Pending' | 'Success' | 'Failure' | 'Canceled'>, pageNumber?: number, pageSize?: number, expand?: Array<'actions'>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PaymentListModel>>;
    public financeFoliosByFolioIdPaymentsGet(folioId: string, statusCodes?: Array<'Pending' | 'Success' | 'Failure' | 'Canceled'>, pageNumber?: number, pageSize?: number, expand?: Array<'actions'>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PaymentListModel>>;
    public financeFoliosByFolioIdPaymentsGet(folioId: string, statusCodes?: Array<'Pending' | 'Success' | 'Failure' | 'Canceled'>, pageNumber?: number, pageSize?: number, expand?: Array<'actions'>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeFoliosByFolioIdPaymentsGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (statusCodes) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                statusCodes.join(COLLECTION_FORMATS['csv']), 'statusCodes');
        }
        if (pageNumber !== undefined && pageNumber !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pageNumber, 'pageNumber');
        }
        if (pageSize !== undefined && pageSize !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pageSize, 'pageSize');
        }
        if (expand) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                expand.join(COLLECTION_FORMATS['csv']), 'expand');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<PaymentListModel>(`${this.configuration.basePath}/finance/v1/folios/${encodeURIComponent(String(folioId))}/payments`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trigger a custom payment for the folio.
     * A custom payment will not involve any automatic processing. This is best to be used for cash, cheque or voucher payments or payments that have  been processed by an external system and it should just be recorded in apaleo for accounting purposes.&lt;br&gt;You must have this scope: \&#39;folios.manage\&#39;.
     * @param folioId
     * @param body The definition of the payment.
     * @param idempotencyKey Unique key for safely retrying requests without accidentally performing the same operation twice.  We\&#39;ll always send back the same response for requests made with the same key,  and keys can\&#39;t be reused with different request parameters. Keys expire after 24 hours.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeFoliosByFolioIdPaymentsPost(folioId: string, body: CreateCustomPaymentRequest, idempotencyKey?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PaymentCreatedModel>;
    public financeFoliosByFolioIdPaymentsPost(folioId: string, body: CreateCustomPaymentRequest, idempotencyKey?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PaymentCreatedModel>>;
    public financeFoliosByFolioIdPaymentsPost(folioId: string, body: CreateCustomPaymentRequest, idempotencyKey?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PaymentCreatedModel>>;
    public financeFoliosByFolioIdPaymentsPost(folioId: string, body: CreateCustomPaymentRequest, idempotencyKey?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeFoliosByFolioIdPaymentsPost.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling financeFoliosByFolioIdPaymentsPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (idempotencyKey !== undefined && idempotencyKey !== null) {
            localVarHeaders = localVarHeaders.set('Idempotency-Key', String(idempotencyKey));
        }

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<PaymentCreatedModel>(`${this.configuration.basePath}/finance/v1/folios/${encodeURIComponent(String(folioId))}/payments`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a refund by ID.
     * Get a refund by its ID&lt;br&gt;You must have at least one of these scopes: \&#39;folios.read, folios.manage\&#39;.
     * @param folioId
     * @param refundId The refund ID.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeFoliosByFolioIdRefundsByRefundIdGet(folioId: string, refundId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<RefundModel>;
    public financeFoliosByFolioIdRefundsByRefundIdGet(folioId: string, refundId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<RefundModel>>;
    public financeFoliosByFolioIdRefundsByRefundIdGet(folioId: string, refundId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<RefundModel>>;
    public financeFoliosByFolioIdRefundsByRefundIdGet(folioId: string, refundId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeFoliosByFolioIdRefundsByRefundIdGet.');
        }
        if (refundId === null || refundId === undefined) {
            throw new Error('Required parameter refundId was null or undefined when calling financeFoliosByFolioIdRefundsByRefundIdGet.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<RefundModel>(`${this.configuration.basePath}/finance/v1/folios/${encodeURIComponent(String(folioId))}/refunds/${encodeURIComponent(String(refundId))}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of refunds.
     * Returns a list of all refunds for this folio ordered by creation date, newest first&lt;br&gt;You must have at least one of these scopes: \&#39;folios.read, folios.manage\&#39;.
     * @param folioId
     * @param statusCodes Filter refunds by one or more status
     * @param pageNumber Page number, starting from 1 and defaulting to 1. Results in 204 if there are no items on that page.
     * @param pageSize Page size. If this is not set, the pageNumber will be ignored and all values returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeFoliosByFolioIdRefundsGet(folioId: string, statusCodes?: Array<'Pending' | 'Success' | 'Failure' | 'Canceled'>, pageNumber?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<RefundListModel>;
    public financeFoliosByFolioIdRefundsGet(folioId: string, statusCodes?: Array<'Pending' | 'Success' | 'Failure' | 'Canceled'>, pageNumber?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<RefundListModel>>;
    public financeFoliosByFolioIdRefundsGet(folioId: string, statusCodes?: Array<'Pending' | 'Success' | 'Failure' | 'Canceled'>, pageNumber?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<RefundListModel>>;
    public financeFoliosByFolioIdRefundsGet(folioId: string, statusCodes?: Array<'Pending' | 'Success' | 'Failure' | 'Canceled'>, pageNumber?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeFoliosByFolioIdRefundsGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (statusCodes) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                statusCodes.join(COLLECTION_FORMATS['csv']), 'statusCodes');
        }
        if (pageNumber !== undefined && pageNumber !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pageNumber, 'pageNumber');
        }
        if (pageSize !== undefined && pageSize !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pageSize, 'pageSize');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<RefundListModel>(`${this.configuration.basePath}/finance/v1/folios/${encodeURIComponent(String(folioId))}/refunds`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trigger a refund for the folio.
     * Trigger a generic refund for the folio. The refund will be processed asynchronously. Use the location header to poll for the status of the refund.  As long as a refund is pending it reduces the amount of allowed refunds for the folio. The refund times out after 60 minutes automatically&lt;br&gt;You must have this scope: \&#39;folios.manage\&#39;.
     * @param folioId
     * @param body The definition of the refund.
     * @param idempotencyKey Unique key for safely retrying requests without accidentally performing the same operation twice.  We\&#39;ll always send back the same response for requests made with the same key,  and keys can\&#39;t be reused with different request parameters. Keys expire after 24 hours.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeFoliosByFolioIdRefundsPost(folioId: string, body: CreateFolioRefundRequest, idempotencyKey?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<RefundCreatedModel>;
    public financeFoliosByFolioIdRefundsPost(folioId: string, body: CreateFolioRefundRequest, idempotencyKey?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<RefundCreatedModel>>;
    public financeFoliosByFolioIdRefundsPost(folioId: string, body: CreateFolioRefundRequest, idempotencyKey?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<RefundCreatedModel>>;
    public financeFoliosByFolioIdRefundsPost(folioId: string, body: CreateFolioRefundRequest, idempotencyKey?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeFoliosByFolioIdRefundsPost.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling financeFoliosByFolioIdRefundsPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (idempotencyKey !== undefined && idempotencyKey !== null) {
            localVarHeaders = localVarHeaders.set('Idempotency-Key', String(idempotencyKey));
        }

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<RefundCreatedModel>(`${this.configuration.basePath}/finance/v1/folios/${encodeURIComponent(String(folioId))}/refunds`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
