/**
 * apaleo Inventory API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { CreateInvoicePdfRequest } from '../model/createInvoicePdfRequest';
// @ts-ignore
import { InvoiceCreatedModel } from '../model/invoiceCreatedModel';
// @ts-ignore
import { InvoiceListModel } from '../model/invoiceListModel';
// @ts-ignore
import { InvoiceModel } from '../model/invoiceModel';
// @ts-ignore
import { MessageItemCollection } from '../model/messageItemCollection';
// @ts-ignore
import { PreviewInvoiceModel } from '../model/previewInvoiceModel';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class InvoiceService {

    protected basePath = 'https://api.apaleo.com';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Gets invoice data.
     * Gets invoice data by its ID. Only works for invoices that have already been created using POST /invoices.&lt;br&gt;You must have this scope: \&#39;invoices.read\&#39;.
     * @param id The invoice ID.
     * @param expand List of all embedded resources that should be expanded in the response. Possible values are: company. All other values will be silently ignored.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeInvoicesByIdGet(id: string, expand?: Array<'company'>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<InvoiceModel>;
    public financeInvoicesByIdGet(id: string, expand?: Array<'company'>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<InvoiceModel>>;
    public financeInvoicesByIdGet(id: string, expand?: Array<'company'>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<InvoiceModel>>;
    public financeInvoicesByIdGet(id: string, expand?: Array<'company'>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling financeInvoicesByIdGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (expand) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                expand.join(COLLECTION_FORMATS['csv']), 'expand');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<InvoiceModel>(`${this.configuration.basePath}/finance/v1/invoices/${encodeURIComponent(String(id))}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets an invoice PDF file.
     * Gets an invoice PDF file by its ID. Only works for invoices that have already been created using POST /invoices.&lt;br&gt;You must have this scope: \&#39;invoices.read\&#39;.
     * @param id The invoice ID.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeInvoicesByIdPdfGet(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/pdf' | 'application/json', context?: HttpContext}): Observable<Blob>;
    public financeInvoicesByIdPdfGet(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/pdf' | 'application/json', context?: HttpContext}): Observable<HttpResponse<Blob>>;
    public financeInvoicesByIdPdfGet(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/pdf' | 'application/json', context?: HttpContext}): Observable<HttpEvent<Blob>>;
    public financeInvoicesByIdPdfGet(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/pdf' | 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling financeInvoicesByIdPdfGet.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/pdf',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        return this.httpClient.get(`${this.configuration.basePath}/finance/v1/invoices/${encodeURIComponent(String(id))}/pdf`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the list of all invoices (the metadata only, not the files).
     * Gets the list of all invoices (the metadata only, not the files).&lt;br&gt;You must have this scope: \&#39;invoices.read\&#39;.
     * @param number The invoice number
     * @param status Filter by invoice status
     * @param checkedOutOnAccountsReceivable If set to {true}, only return invoices with an open balance (AR)  Otherwise, returns all.
     * @param outstandingPaymentFilter Filter for the outstanding balance for invoices&lt;br /&gt;You can provide an array of string expressions which all need to apply.&lt;br /&gt;Each expression has the form of \&#39;OPERATION_VALUE\&#39; where VALUE needs to be of the valid format of the property type and OPERATION can be:&lt;br /&gt;\&#39;eq\&#39; for equals&lt;br /&gt;\&#39;neq\&#39; for not equals&lt;br /&gt;\&#39;lt\&#39; for less than&lt;br /&gt;\&#39;gt\&#39; for greater than&lt;br /&gt;\&#39;lte\&#39; for less than or equals&lt;br /&gt;\&#39;gte\&#39; for greater than or equals&lt;br /&gt;For instance&lt;br /&gt;\&#39;eq_5\&#39; would mean the value should equal 5&lt;br /&gt;\&#39;lte_7\&#39; would mean the value should be less than or equal to 7
     * @param dateFilter Filter by invoice date&lt;br /&gt;You can provide an array of string expressions which all need to apply.&lt;br /&gt;Each expression has the form of \&#39;OPERATION_VALUE\&#39; where VALUE needs to be of the valid format of the property type and OPERATION can be:&lt;br /&gt;\&#39;eq\&#39; for equals&lt;br /&gt;\&#39;neq\&#39; for not equals&lt;br /&gt;\&#39;lt\&#39; for less than&lt;br /&gt;\&#39;gt\&#39; for greater than&lt;br /&gt;\&#39;lte\&#39; for less than or equals&lt;br /&gt;\&#39;gte\&#39; for greater than or equals&lt;br /&gt;For instance&lt;br /&gt;\&#39;eq_5\&#39; would mean the value should equal 5&lt;br /&gt;\&#39;lte_7\&#39; would mean the value should be less than or equal to 7
     * @param propertyIds Filter by property IDs
     * @param reservationIds Filter by reservation IDs
     * @param folioIds Filter by folio IDs
     * @param nameSearch Find invoices for a recipient name or company. Provide at least three characters.
     * @param paymentSettled If set to {true}, returns only invoices having no outstanding payments or marked as settled.  If set to {false}, returns only invoices with outstanding payment and not marked as settled.  If not set, returns all invoices.
     * @param companyIds Filter by company IDs
     * @param pageNumber Page number, starting from 1 and defaulting to 1. Results in 204 if there are no items on that page.
     * @param pageSize Page size. If this is not set, the pageNumber will be ignored and all values returned.
     * @param expand List of all embedded resources that should be expanded in the response. Possible values are: allowedActions, company. All other values will be silently ignored.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeInvoicesGet(number?: string, status?: 'FullyPaid' | 'Unpaid', checkedOutOnAccountsReceivable?: boolean, outstandingPaymentFilter?: Array<string>, dateFilter?: Array<string>, propertyIds?: Array<string>, reservationIds?: Array<string>, folioIds?: Array<string>, nameSearch?: string, paymentSettled?: boolean, companyIds?: Array<string>, pageNumber?: number, pageSize?: number, expand?: Array<'allowedActions' | 'company'>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<InvoiceListModel>;
    public financeInvoicesGet(number?: string, status?: 'FullyPaid' | 'Unpaid', checkedOutOnAccountsReceivable?: boolean, outstandingPaymentFilter?: Array<string>, dateFilter?: Array<string>, propertyIds?: Array<string>, reservationIds?: Array<string>, folioIds?: Array<string>, nameSearch?: string, paymentSettled?: boolean, companyIds?: Array<string>, pageNumber?: number, pageSize?: number, expand?: Array<'allowedActions' | 'company'>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<InvoiceListModel>>;
    public financeInvoicesGet(number?: string, status?: 'FullyPaid' | 'Unpaid', checkedOutOnAccountsReceivable?: boolean, outstandingPaymentFilter?: Array<string>, dateFilter?: Array<string>, propertyIds?: Array<string>, reservationIds?: Array<string>, folioIds?: Array<string>, nameSearch?: string, paymentSettled?: boolean, companyIds?: Array<string>, pageNumber?: number, pageSize?: number, expand?: Array<'allowedActions' | 'company'>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<InvoiceListModel>>;
    public financeInvoicesGet(number?: string, status?: 'FullyPaid' | 'Unpaid', checkedOutOnAccountsReceivable?: boolean, outstandingPaymentFilter?: Array<string>, dateFilter?: Array<string>, propertyIds?: Array<string>, reservationIds?: Array<string>, folioIds?: Array<string>, nameSearch?: string, paymentSettled?: boolean, companyIds?: Array<string>, pageNumber?: number, pageSize?: number, expand?: Array<'allowedActions' | 'company'>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (number !== undefined && number !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>number, 'number');
        }
        if (status !== undefined && status !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>status, 'status');
        }
        if (checkedOutOnAccountsReceivable !== undefined && checkedOutOnAccountsReceivable !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>checkedOutOnAccountsReceivable, 'checkedOutOnAccountsReceivable');
        }
        if (outstandingPaymentFilter) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                outstandingPaymentFilter.join(COLLECTION_FORMATS['csv']), 'outstandingPaymentFilter');
        }
        if (dateFilter) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                dateFilter.join(COLLECTION_FORMATS['csv']), 'dateFilter');
        }
        if (propertyIds) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                propertyIds.join(COLLECTION_FORMATS['csv']), 'propertyIds');
        }
        if (reservationIds) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                reservationIds.join(COLLECTION_FORMATS['csv']), 'reservationIds');
        }
        if (folioIds) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                folioIds.join(COLLECTION_FORMATS['csv']), 'folioIds');
        }
        if (nameSearch !== undefined && nameSearch !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>nameSearch, 'nameSearch');
        }
        if (paymentSettled !== undefined && paymentSettled !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paymentSettled, 'paymentSettled');
        }
        if (companyIds) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                companyIds.join(COLLECTION_FORMATS['csv']), 'companyIds');
        }
        if (pageNumber !== undefined && pageNumber !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pageNumber, 'pageNumber');
        }
        if (pageSize !== undefined && pageSize !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pageSize, 'pageSize');
        }
        if (expand) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                expand.join(COLLECTION_FORMATS['csv']), 'expand');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<InvoiceListModel>(`${this.configuration.basePath}/finance/v1/invoices`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates an invoice for one specific folio.
     * Creates an invoice for one specific folio. The invoice can only be created once.  The debitor needs to have name, city, postal code and country code, as these are required for invoices.  If the folio is not fully paid, this will check out the reservation on AR and create an invoice with outstanding payments.&lt;br&gt;You must have at least one of these scopes: \&#39;invoices.create, invoices.manage\&#39;.
     * @param body The folio ID to create the invoice for.
     * @param idempotencyKey Unique key for safely retrying requests without accidentally performing the same operation twice.  We\&#39;ll always send back the same response for requests made with the same key,  and keys can\&#39;t be reused with different request parameters. Keys expire after 24 hours.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeInvoicesPost(body: CreateInvoicePdfRequest, idempotencyKey?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<InvoiceCreatedModel>;
    public financeInvoicesPost(body: CreateInvoicePdfRequest, idempotencyKey?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<InvoiceCreatedModel>>;
    public financeInvoicesPost(body: CreateInvoicePdfRequest, idempotencyKey?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<InvoiceCreatedModel>>;
    public financeInvoicesPost(body: CreateInvoicePdfRequest, idempotencyKey?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling financeInvoicesPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (idempotencyKey !== undefined && idempotencyKey !== null) {
            localVarHeaders = localVarHeaders.set('Idempotency-Key', String(idempotencyKey));
        }

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<InvoiceCreatedModel>(`${this.configuration.basePath}/finance/v1/invoices`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets an invoice preview for one specific folio.
     * To see if the invoice creation would be successful, check the warnings.&lt;br&gt;You must have this scope: \&#39;invoices.read\&#39;.
     * @param folioId The ID of the folio for which the invoice should be created.
     * @param expand List of all embedded resources that should be expanded in the response. Possible values are: company. All other values will be silently ignored.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeInvoicesPreviewGet(folioId: string, expand?: Array<'company'>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PreviewInvoiceModel>;
    public financeInvoicesPreviewGet(folioId: string, expand?: Array<'company'>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PreviewInvoiceModel>>;
    public financeInvoicesPreviewGet(folioId: string, expand?: Array<'company'>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PreviewInvoiceModel>>;
    public financeInvoicesPreviewGet(folioId: string, expand?: Array<'company'>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeInvoicesPreviewGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (folioId !== undefined && folioId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>folioId, 'folioId');
        }
        if (expand) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                expand.join(COLLECTION_FORMATS['csv']), 'expand');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<PreviewInvoiceModel>(`${this.configuration.basePath}/finance/v1/invoices/preview`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a preview invoice PDF for one specific folio.
     * Gets a preview invoice PDF for one specific folio.&lt;br&gt;You must have this scope: \&#39;invoices.read\&#39;.
     * @param languageCode The language in which the invoice should be produced.
     * @param folioId The ID of the folio for which the invoice should be created.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public financeInvoicesPreviewPdfGet(languageCode: string, folioId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/pdf' | 'application/json', context?: HttpContext}): Observable<Blob>;
    public financeInvoicesPreviewPdfGet(languageCode: string, folioId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/pdf' | 'application/json', context?: HttpContext}): Observable<HttpResponse<Blob>>;
    public financeInvoicesPreviewPdfGet(languageCode: string, folioId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/pdf' | 'application/json', context?: HttpContext}): Observable<HttpEvent<Blob>>;
    public financeInvoicesPreviewPdfGet(languageCode: string, folioId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/pdf' | 'application/json', context?: HttpContext}): Observable<any> {
        if (languageCode === null || languageCode === undefined) {
            throw new Error('Required parameter languageCode was null or undefined when calling financeInvoicesPreviewPdfGet.');
        }
        if (folioId === null || folioId === undefined) {
            throw new Error('Required parameter folioId was null or undefined when calling financeInvoicesPreviewPdfGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (languageCode !== undefined && languageCode !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>languageCode, 'languageCode');
        }
        if (folioId !== undefined && folioId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>folioId, 'folioId');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/pdf',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        return this.httpClient.get(`${this.configuration.basePath}/finance/v1/invoices/preview-pdf`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
